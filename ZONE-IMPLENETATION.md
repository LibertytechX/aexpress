This refined journey outlines the logic required to move a package across Lagos using the Point + Radius Model, Ably real-time layers, and multi-hop relay logic. This specific implementation allows an order to be "chained" across as many zones and relay points as necessary to ensure no single rider ever exceeds their 15km efficiency cap.Phase 1: Infrastructure & Data SeedingBefore the first order is placed, the digital grid is established in the Django backend.Zone Seeding (Point Model): * Identify central coordinates (Landmarks) in Lagos.Assign each a center (PointField) and a radius_km (e.g., 5km–10km).Relay Node Network: * Register physical handoff points (RelayNodes) at strategic intersections.Fleet Onboarding: * 100 Riders are registered and linked to a "Home Zone" point for accountability.Routing Engine Integration: * Connect the backend to a routing engine (OSRM/GraphHopper) that uses OpenStreetMap data to ensure paths stay on roads and ignore water.Phase 2: Order Creation & Infinite Relay PathfindingThe "Intelligence" happens the moment the customer hits "Request."Ingestion: Customer sets Pickup and Drop-off coordinates.Dijkstra’s Algorithm Execution: * The routing engine calculates the Shortest Road Path.The "Water" Check: Dijkstra naturally ignores non-road segments (lagoons, ocean), ensuring the 15km limit applies only to actual tarmac travel.Dynamic Segmenting: * The system divides the total path into $N$ number of legs, where each leg is $\leq 15\text{km}$.If a trip is 60km, the backend automatically generates 4 sequential legs.Object Generation: * One Order (Parent) is created.$N$ number of OrderLeg (Children) are generated for every 15km "hop" required to reach the destination.Phase 3: The Aggregator & Dispatch (Leg 1)Getting the first rider to the merchant.Spatial Filter (15km Radius): * Backend queries for all riders within a 15km radius of the Pickup Point.Candidate Validation: * System checks Ably Presence to ensure riders are "Online."Dispatcher View: * Dispatcher sees a list of riders ranked by road-distance ETA.Acceptance: * Rider 1 accepts via Flutter; Leg 1 moves to In-Progress.Phase 4: Active Transit & Predictive TriggerManaging the handoff before the current rider even arrives at the relay point.High-Frequency Tracking: Rider app streams GPS to Ably every 5–10 seconds.Abandonment Monitoring: * Backend compares the rider's position to their "Home Zone" center.If distance > 10km (or your chosen threshold), a "Drifting" flag is raised in the dashboard.The 2km Proximity Trigger: * As the current rider approaches the RelayNode (End of current Leg), the system detects they are < 2km away.Next Leg Discovery: * Backend automatically triggers a new aggregation query for riders within 15km of that Relay Node.Phase 5: The "Handshake" & HandoffEnsuring zero-downtime transition between the chain of riders.Ably Relay Alert: Next-leg riders receive a NEW_RELAY_LEG notification.Rider Acceptance: The next rider in the chain accepts and moves to the Relay Node.Live Coordination: Both riders see each other’s live positions on the Flutter map via Ably to time the meet-up perfectly.Verification: * Riders meet at the Relay Node.The receiving rider scans the current rider’s QR code.Chain Transition: * Current Leg marked Completed.Next Leg marked Active.Phase 6: Final Mile & SettlementFinal Leg Completion: The final rider in the chain completes the drop-off.Global Close: The Parent Order is marked as Delivered.Automated Settlement: * Backend calculates the payout split based on the number of "Hops" performed.Performance bonuses are applied for riders who maintained "Zone Compliance" (did not drift too far from their assigned point).Technical Summary ChecklistPostGIS: For PointField and ST_DWithin queries.OSRM/GraphHopper: For Dijkstra road-path calculations that bypass water.Ably: For GPS streaming, Presence (online status), and the 2km Predictive Alert.Flutter: To handle the multi-rider map visualization and QR verification.


Analysis with code

This refined journey outlines the logic required to move a package across Lagos using the Point + Radius Model, Ably real-time layers, and multi-hop relay logic. This specific implementation allows an order to be "chained" across as many zones and relay points as necessary to ensure no single rider ever exceeds their 15km efficiency cap.Phase 1: Infrastructure & Data SeedingBefore the first order is placed, the digital grid is established in the Django backend.Zone Seeding (Point Model): * Identify central coordinates (Landmarks) in Lagos.Assign each a center (PointField) and a radius_km (e.g., 5km–10km).Relay Node Network: * Register physical handoff points (RelayNodes) at strategic intersections.Fleet Onboarding: * 100 Riders are registered and linked to a "Home Zone" point for accountability.Routing Engine Integration: * Connect the backend to a routing engine (OSRM/GraphHopper) that uses OpenStreetMap data to ensure paths stay on roads and ignore water.Phase 2: Order Creation & Infinite Relay PathfindingThe "Intelligence" happens the moment the customer hits "Request."Ingestion: Customer sets Pickup and Drop-off coordinates.Dijkstra’s Algorithm Execution: * The routing engine calculates the Shortest Road Path.The "Water" Check: Dijkstra naturally ignores non-road segments (lagoons, ocean), ensuring the 15km limit applies only to actual tarmac travel.Dynamic Segmenting: * The system divides the total path into $N$ number of legs, where each leg is $\leq 15\text{km}$.If a trip is 60km, the backend automatically generates 4 sequential legs.Object Generation: * One Order (Parent) is created.$N$ number of OrderLeg (Children) are generated for every 15km "hop" required to reach the destination.Phase 3: The Aggregator & Dispatch (Leg 1)Getting the first rider to the merchant.Spatial Filter (15km Radius): * Backend queries for all riders within a 15km radius of the Pickup Point.Candidate Validation: * System checks Ably Presence to ensure riders are "Online."Dispatcher View: * Dispatcher sees a list of riders ranked by road-distance ETA.Acceptance: * Rider 1 accepts via Flutter; Leg 1 moves to In-Progress.Phase 4: Active Transit & Predictive TriggerManaging the handoff before the current rider even arrives at the relay point.High-Frequency Tracking: Rider app streams GPS to Ably every 5–10 seconds.Abandonment Monitoring: * Backend compares the rider's position to their "Home Zone" center.If distance > 10km (or your chosen threshold), a "Drifting" flag is raised in the dashboard.The 2km Proximity Trigger: * As the current rider approaches the RelayNode (End of current Leg), the system detects they are < 2km away.Next Leg Discovery: * Backend automatically triggers a new aggregation query for riders within 15km of that Relay Node.Phase 5: The "Handshake" & HandoffEnsuring zero-downtime transition between the chain of riders.Ably Relay Alert: Next-leg riders receive a NEW_RELAY_LEG notification.Rider Acceptance: The next rider in the chain accepts and moves to the Relay Node.Live Coordination: Both riders see each other’s live positions on the Flutter map via Ably to time the meet-up perfectly.Verification: * Riders meet at the Relay Node.The receiving rider scans the current rider’s QR code.Chain Transition: * Current Leg marked Completed.Next Leg marked Active.Phase 6: Final Mile & SettlementFinal Leg Completion: The final rider in the chain completes the drop-off.Global Close: The Parent Order is marked as Delivered.Automated Settlement: * Backend calculates the payout split based on the number of "Hops" performed.Performance bonuses are applied for riders who maintained "Zone Compliance" (did not drift too far from their assigned point).Technical Summary ChecklistPostGIS: For PointField and ST_DWithin queries.OSRM/GraphHopper: For Dijkstra road-path calculations that bypass water.Ably: For GPS streaming, Presence (online status), and the 2km Predictive Alert.Flutter: To handle the multi-rider map visualization and QR verification.


How are relay nodes pre-seeded? We need a view in zone settings to add these points by providing addrresses that geocode into coordinates. and show in the map view in the settings. each zone will have a radius value saved alongside.

What's the minimum viable fleet density? riders in position simultaneously.? packages can be dropped off at the hub while pending arrival of the relay relief rider

A rider who does a 14km leg should arguably earn more than one who does a 3km leg. - Yes correct

What happens to the package if a rider goes offline mid-leg? The Ably presence check happens at dispatch, but a rider can go dark after accepting.- - Lets ignore this for now.


Implementation Plan — AX Relay Delivery System
Step 1 — Foundation (Backend Models + PostGIS)
Install PostGIS, add Zone, RelayNode, OrderLeg models, extend the existing Order model to be a parent, run migrations. This is the data layer everything else sits on. No routing, no UI — just clean schema.

Step 2 — Zone & Relay Node Management UI
Add a new tab in the dispatcher portal Settings page. Address input → geocode to coordinates → save RelayNode to backend. Render all nodes on the existing Lagos map as pins with radius circles. Full CRUD (add, edit, deactivate).

Step 3 — Routing Engine + Leg Generation
Integrate OSRM (self-hosted). On order creation, run Dijkstra on the pickup→dropoff road path, select relay nodes along that path keeping each leg ≤15km, generate OrderLeg records. Lock in distance-weighted rider payouts at this point — riders know earnings before accepting.

Step 4 — Dispatch Pipeline + Real-time Relay
Per-leg rider assignment using ST_DWithin + Ably Presence check. Rider streams GPS every 10s. When ETA to relay hub < 5 minutes, trigger next-leg aggregation. Current rider drops at hub (hub agent confirms receipt). Next rider picks up when available — hub holds in the interim.

Step 5 — Settlement + Completion Chain
On each leg completion, mark OrderLeg as Completed, auto-activate next leg. When final leg delivers, close the parent Order as Delivered, calculate and record each rider's payout (leg_km / total_km × rider_pool), apply zone compliance bonus where earned.

